package com.demo.config.batch;

import com.demo.dto.Eligibilite;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.JobRegistry;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemStreamReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.classify.Classifier;
import org.springframework.cloud.task.configuration.EnableTask;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
@EnableTask
@EnableBatchProcessing
public class BatchConfiguration {
	
	@Autowired
	private JobRegistry jobRegistry;
	
	@Autowired
	private DataSource dataSource;
	
	@Autowired
	private JobBuilderFactory jobs;
	
	@Autowired
	private StepBuilderFactory steps;

	
	@Bean
	public Job importUserJob() {
		return jobs.get("databaseToDatabaseJob")
				.incrementer(new RunIdIncrementer())
				.start(step1())
				.build();
	}

	String query="with detected as (   " +
			"   select * from tiers_random   " +
			"   where id_tiers in (select id_tiers    " +
			"                  from  tiers_guichets_random    " +
			"                  where nature_lien_pp_pm_cg = 1   " +
			"                  and code_banque||'-'||code_guichet||'-'||num_client in (select code_banque||'-'||code_guichet||'-'||num_client   " +
			"                                                      from guichet_random   " +
			"                                                   where  guichet_statut=1))  limit " +
			"),existing as (select * from eligibilite_random)   " +
			"select id_tiers,code_source, 'create' status   " +
			"from prestations_random   " +
			"where id_tiers in (select id_tiers from detected)   " +
			"and  id_tiers not in (select id_tiers from existing )   " +
			"union   " +
			"select id_tiers, null code_source, 'delete' status   " +
			"from existing   " +
			"where  id_tiers not in  (select id_tiers from detected ) ";
	@Bean
	public Step step1() {
		return steps.get("databaseToDatabaseStep")
				.<Eligibilite, Eligibilite> chunk(100)
				.reader(reader())
				.processor(processor())
				.writer(classifierCompositeItemWriter(eligibiliteInsertWriter(),eligibiliteDeleteWriter()))
				.build();
				
						


		
	}
	
	
	@Bean
	public ItemStreamReader<Eligibilite> reader() {
			JdbcCursorItemReader<Eligibilite> reader = new JdbcCursorItemReader<Eligibilite>();
		reader.setDataSource(dataSource);
		reader.setFetchSize(100);
		reader.setSql(query);
		reader.setRowMapper(new EligibiliteRowMapper());
		return reader;
	}

	@Bean
	public ItemProcessor<Eligibilite, Eligibilite> processor() {
		return new EligibiliteItemProcessor();
	}

	@Bean
	public ItemWriter<Eligibilite> eligibiliteInsertWriter() {
		JdbcBatchItemWriter<Eligibilite> writer = new JdbcBatchItemWriter<Eligibilite>();
		writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<Eligibilite>());
		
		writer.setSql("INSERT INTO eligibilite (id_tiers) VALUES (:idTiers)");
		writer.setDataSource(dataSource);
		return writer;
	}

	@Bean
	public ItemWriter<Eligibilite> eligibiliteDeleteWriter() {
		JdbcBatchItemWriter<Eligibilite> eligibiliteInsertWriter = new JdbcBatchItemWriter<Eligibilite>();
		eligibiliteInsertWriter.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<Eligibilite>());

		eligibiliteInsertWriter.setSql("delete from  eligibilite where id_tiers=:idTiers");
		eligibiliteInsertWriter.setDataSource(dataSource);
		return eligibiliteInsertWriter;
	}

	@Bean
	public ClassifierCompositeItemWriter<Eligibilite> classifierCompositeItemWriter(
			ItemWriter< Eligibilite> eligibiliteInsertWriter,
			ItemWriter< Eligibilite> eligibiliteDeleteWriter
	) {
		ClassifierCompositeItemWriter< Eligibilite> classifierCompositeItemWriter = new ClassifierCompositeItemWriter<>();
		classifierCompositeItemWriter.setClassifier(new Classifier<Eligibilite, ItemWriter<? super Eligibilite>>() {
			@Override
			public ItemWriter<? super  Eligibilite> classify( Eligibilite eligibilite) {
				if (eligibilite.getStatus().equalsIgnoreCase("create")) {
					return eligibiliteInsertWriter;
				} else {
					return eligibiliteDeleteWriter;
				}
			}
		});
		return classifierCompositeItemWriter;
	}

}
////
package com.demo.config.batch;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class DetectionEligibiliteDto {
    private String idTiers;
}
//
package com.demo.config.batch;

import org.springframework.batch.item.ItemProcessor;

public class DetectionItemProcessor implements ItemProcessor<DetectionEligibiliteDto, DetectionEligibiliteDto> {
    @Override
    public DetectionEligibiliteDto process(final DetectionEligibiliteDto infoTiersDto) throws Exception {
    	
        return DetectionEligibiliteDto.builder().build();
    }
}

//
package com.demo.config.batch;

import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

public class DetectionRowMapper implements RowMapper<DetectionEligibiliteDto> {

	@Override
	public DetectionEligibiliteDto mapRow(ResultSet rs, int rowNum) throws SQLException {
		DetectionEligibiliteDto eligibiliteDto  =DetectionEligibiliteDto.builder()
				.idTiers(rs.getString("id_tiers"))
				.build();
		
		return eligibiliteDto;
	}
 
}

///
package com.demo.config.batch;

import com.demo.commons.EligibiliteStatus;
import com.demo.dto.Eligibilite;
import org.springframework.batch.item.ItemProcessor;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class EligibiliteItemProcessor implements ItemProcessor<Eligibilite, Eligibilite> {
    @Override
    public Eligibilite process(final Eligibilite infoTiersDto) throws Exception {

        Map<EligibiliteStatus, Set<DetectionEligibiliteDto>> eligibilites = new ConcurrentHashMap<>();
                
        Eligibilite eligibilite= Eligibilite.builder()
                .idTiers(infoTiersDto.getIdTiers())
                .build();
        
        return eligibilite;
    }
}

//
package com.demo.config.batch;

import com.demo.dto.Eligibilite;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

public class EligibiliteRowMapper implements RowMapper<Eligibilite> {

	@Override
	public Eligibilite mapRow(ResultSet rs, int rowNum) throws SQLException {
		Eligibilite eligibilite =  Eligibilite.builder()
				.idTiers(rs.getString("id_tiers"))
				.build();
		
		return eligibilite;
	}
 
}

///
package com.demo.dto;

public abstract class AbstractDto {
}

///

package com.demo.dto;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class Eligibilite extends AbstractDto {
    private String idTiers;
    private boolean topEligibilite;
    private boolean topCotation;
    private boolean topOppChequier;
    private boolean topRevenusFrais;
    private boolean topUsageAbusifCarte;
    private boolean dateDebutEligibilite;
    private boolean dateFinEligibilite;
    private boolean topFragiliteFft;
    private String status;
    private String codeSource;
    
    
    
}


